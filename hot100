输入: 1->2->2->1
输出: true
1.使用栈：将链表全部压栈，然后一边遍历链表一边和栈顶元素比较，相同则弹出栈顶元素，最后栈空返回true
2.将链表元素存入数组中，然后用双指针遍历
3.使用快慢指针+逆转前半部分的节点，注意如果链表节点个数如果为奇数，slow指针要跳过中间节点
class Solution {
private:
    stack<int> st;
public:
    bool isPalindrome(ListNode* head) {
        // ListNode *p=head;
        // while(p){
        //     st.push(p->val);
        //     p=p->next;
        // }
        // while(!st.empty()&&head){
        //     if(st.top()==head->val){
        //         st.pop();
        //     }
        //     else return false;
        //     head=head->next;
        // }
        // if(st.empty()) return true;
        // return false;

        // vector<int>vec;
        // ListNode* p=head;
        // while(p){
        //     vec.push_back(p->val);
        //     p=p->next;
        // }
        // for(int i=0,j=vec.size()-1;i<j;i++,j--){
        //     if(vec[i]!=vec[j]) return false;
        // }
        // return true;

        //快慢指针
        if(head->next==NULL||head==NULL) return true;
        ListNode *fast=head,*slow=head;
        ListNode* p,*pre=NULL;
        while(fast&&fast->next){
            p=slow;
            slow=slow->next;
            fast=fast->next->next;
            p->next=pre; //逆转
            pre=p;
        }
        if(fast){
            slow=slow->next; //奇数，跳过中间节点
        }
        while(p){
            if(p->val!=slow->val) return false;
            p=p->next;
            slow=slow->next;
        }
        return true;
    }
};

461. 汉明距离
两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。
思路：将两个数进行异或，不同位置的数目就是二进制中1的个数
然后用n&(n-1)可以使最后一位二进制变为0
class Solution {
public:
    int hammingDistance(int x, int y) {
        int ret=0;
        int num=x^y;
        while(num!=0){
            ret++;
            num=num&(num-1);
        }
        return ret;
    }
};

543. 二叉树的直径
给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
思路：二叉树的直径长度可以由左右子树的深度拼接得到，向左儿子遍历最多的节点数为L，右儿子遍历最多的节点为R，那从该节点为起点的路径经过的节点数的最大值为L+R+1
class Solution {
public:
    int diameterOfBinaryTree(TreeNode* root) {
        ans=1;
        Count(root);
        return ans-1;
    }
private:
    int ans;
    int Count(TreeNode* root){
        if(root==nullptr) return 0; //访问到空结点了，返回0
        int left=Count(root->left); //左儿子为根的树的深度
        int right=Count(root->right); //右儿子为根的树的深度
        ans=max(ans,left+right+1); //计算（L+R+1）,更新最大节点数的值
        return max(left,right)+1;  //返回该节点为根的子树的深度
    }
};

617. 合并二叉树
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        // TreeNode* root;
        if(root1==nullptr) return root2;
        if(root2==nullptr) return root1;
        root1->val+=root2->val;
        root1->left=mergeTrees(root1->left,root2->left);
        root1->right=mergeTrees(root1->right,root2->right);
        return root1;
    }
};

209. 长度最小的子数组



思路：滑动窗口控制和大于target的最少整数个数，双指针指向窗口的边界，不断向前调整、
时间复杂度o(n)，空间o(1)
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int sum=0;
        int res=INT_MAX;
        int i=0; //滑动窗口左边界
        for(int j=0;j<nums.size();j++){
            sum+=nums[j];
            while(sum>=target){
                int sublenth=j-i+1;
                res=res<sublenth?res:sublenth;
                sum-=nums[i++];
            }
        }
        if(res==INT_MAX) return 0;
        return res;
    }
};

28. 实现 strStr()
KMP算法思路：
class Solution {
public:
    void getNext(int* next,const string& s){
        int j=-1;  //i指向的是后缀末尾，j指向的是前缀的末尾
        next[0]=j;
        for(int i=1;i<s.size();i++){ //注意i从1开始，这样才能和前面的位置0比较
            //前后缀不匹配时，回退
            while(j>=0&&s[i]!=s[j+1]){
                j=next[j]; 
            }
            if(s[i]==s[j+1]){
                j++;
            }
            next[i]=j;  //j实际上就是前后缀相等的长度
        }
    }
    int strStr(string haystack, string needle) {
        if(needle.size()==0) return 0;
        int next[needle.size()];
        getNext(next,needle);
        int j=-1; //j是遍历子串的指针,next数组里记录的起始位置为-1所以j起始为-1
        for(int i=0;i<haystack.size();i++){  //注意i从0开始
            while(j>=0&&needle[j+1]!=haystack[i]){
                j=next[j];  //子串和母串不匹配的时候，子串根据Next回退
            }
            if(haystack[i]==needle[j+1]){
                j++;// 匹配，同时向后移
            }
            //首次出现模式串的时候，返回的位置就是当前i的位置剪掉字串长度
            if(j==(needle.size()-1)){
                return (i-needle.size()+1);
            }
        }
        return -1;
    }
};

15. 三数之和
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
排序+双指针（两层循环，第二层和第三层实际上就是双指针）
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        if(nums.size()<3) return {};
        //将数组排序，a<b<c，这样减少重复
        sort(nums.begin(),nums.end());
        vector<vector<int>> ans;
        for(int first=0;first<nums.size();first++){
            //第一层，如果和前一个相等，跳过
            if(first>0&&nums[first]==nums[first-1]) continue;
            int target=-nums[first];
            int third=nums.size()-1;
            for(int second=first+1;second<nums.size();second++){
                //第二层，如果和前面相等就跳过
                if(second>first+1&&nums[second]==nums[second-1]) continue;
                //second和third位置的值相加,如果大于target，third--
                while(third>second&&(nums[third]+nums[second])>target) third--;
                if(third==second) break;
                //三者之和为0，放入结果集中
                if(nums[third]+nums[second]==target){
                    ans.push_back({nums[first],nums[second],nums[third]});
                }
            }
        }
        return ans;
    }
};

98. 验证二叉搜索树
法一：节点的值在范围low和high之间，节点值不在区间内返回false，递归遍历左子树时，右边界更新为根节点的值，递归遍历右子树时左边界更新为根节点的值
时间复杂度O(n),空间O(n)
class Solution{
public:
    bool judge(TreeNode* root,long long low,long long high){
        if(root==nullptr) return true;
        if(root->val<=low||root->val>=high) return false;
        return judge(root->left,low,root->val)&&judge(root->right,root->val,high);
    }
    bool isValidBST(TreeNode* root){
        return judge(root,LONG_MIN,LONG_MAX);    
    }
};

法二：中序遍历二叉树，如果是从小到大排序的，返回true。定义一个变量值指向前一个节点值，利用栈，先将根节点的所有左节点入栈，取栈顶元素判断是否比前面的大，否则返回false，然后遍历栈顶元素的右节点
class Solution{
    public:
        bool isValidBST(TreeNode *root){
        stack<TreeNode*> st;
        long long inorder=LONG_MIN;
        while(!st.empty()||root!=nullptr){
            while(root){
                st.push(root);
                root=root->left;
            }
            root=st.top();
            st.pop();
            if(root->val<=inorder) return false;
            inorder=root->val;
            root=root->right;
        }
        return true;
    }
};

224. 基本计算器
给你一个字符串表达式 
s ，请你实现一个基本计算器来计算并返回它的值。
输入：s = "1 + 1"
输出：2
class Solution {
public:
    //栈里存放符号，遇到+符号就为1，遇到-就反转符号，遇到'('将符号入栈，遇到‘)‘将符号出栈
    int calculate(string s) {
        stack<int> ops;
        ops.push(1);
        int sign = 1;

        int ret = 0;
        int n = s.length();
        int i = 0;
        while (i < n) {
            if (s[i] == ' ') {
                i++;
            } else if (s[i] == '+') {
                sign = ops.top();
                i++;
            } else if (s[i] == '-') {
                sign = -ops.top();
                i++;
            } else if (s[i] == '(') {
                ops.push(sign);
                i++;
            } else if (s[i] == ')') {
                ops.pop();
                i++;
            } else {
                long num = 0;  //注意num是long类型，小心栈溢出
                while (i < n && s[i] >= '0' && s[i] <= '9') {
                    num = num * 10 + s[i] - '0';
                    i++;
                }
                ret += sign * num;
            }
        }
        return ret;
    }

94. 二叉树的中序遍历
1.递归方式 2.非递归方式，使用辅助栈
    vector<int> inorderTraversal(TreeNode* root){
        if(root==nullptr) return {};
        vector<int>res;
        stack<TreeNode*>stack;
        while(!stack.empty()||root!=nullptr){
            while(root){
                stack.push(root);
                root=root->left;
            }
            root=stack.top();
            stack.pop();
            res.push_back(root->val);
            root=root->right;
        }
        return res;
    }

3. 无重复字符的最长子串
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

思路：双指针+集合set，有一点点像滑动窗口，i作为子串的首部，j作为子串的尾部，每次判断新加进来的字符是否在set中存在
左指针向右移动一格，set移除一个字符，右指针向前移动时，insert插入set中，同时判断是否重复
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.size()==0) return 0;
        int n=s.size();
        unordered_set<char>myset;
        int right=-1;//右指针初始为-1，相当于还在字符串的左边界的左侧，还没移动
        int res=0;
        //枚举左指针的位置
        for(int i=0;i<s.size();++i){
            if(i!=0){
                myset.erase(s[i-1]);//左指针向右移动，erase一个字符
            }
            while(right+1<s.size()&&!myset.count(s[right+1])){
                //不断移动右指针
                myset.insert(s[right+1]);
                ++right;
            }
            //第i到right个字符是最大的无重复的字符子串
            res=max(res,right-i+1);
        }
        return res;
    }
};

581. 最短无序连续子数组
给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。
请你找出符合题意的 最短 子数组，并输出它的长度。
输入：nums = [2,6,4,8,10,9,15]
输出：5
解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。

思路：找连续子数组，其实就是找左边界子数组的最小值要大于左边界
class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) {
        if(nums.size()<=1) return 0;
        int n=nums.size();
        int l=n-1,min_num=nums[n-1];
        for(int i=n-1;i>=0;i--){
            if(nums[i]>min_num){
                l=i;
            }
            min_num=min(min_num,nums[i]);
        }
        int r=0,max_num=nums[0];
        for(int j=0;j<n;j++){
            if(nums[j]<max_num){
                r=j;
            }
            max_num=max(max_num,nums[j]);
        }
        if(l>r) return 0;
        return r-l+1;
    }
};

LRU缓存机制
struct DLinkedNode {
    int key, value;
    DLinkedNode* prev;
    DLinkedNode* next;
    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}
    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}
};

class LRUCache {
private:
    unordered_map<int, DLinkedNode*> cache;
    DLinkedNode* head;
    DLinkedNode* tail;
    int size;
    int capacity;
public:
    LRUCache(int _capacity): capacity(_capacity), size(0) {
        // 使用伪头部和伪尾部节点
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head->next = tail;
        tail->prev = head;
    }
    int get(int key) {
        if (!cache.count(key)) {
            return -1;
        }
        // 如果 key 存在，先通过哈希表定位，再移到头部
        DLinkedNode* node = cache[key];
        moveToHead(node);
        return node->value;
    }
    void put(int key, int value) {
        if (!cache.count(key)) {
            // 如果 key 不存在，创建一个新的节点
            DLinkedNode* node = new DLinkedNode(key, value);
            // 添加进哈希表
            cache[key] = node;
            // 添加至双向链表的头部
            addToHead(node);
            ++size;
            if (size > capacity) {
                // 如果超出容量，删除双向链表的尾部节点
                DLinkedNode* removed = removeTail();
                // 删除哈希表中对应的项
                cache.erase(removed->key);
                // 防止内存泄漏
                delete removed;
                --size;
            }
        }
        else {
            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            DLinkedNode* node = cache[key];
            node->value = value;
            moveToHead(node);
        }
    }
    void addToHead(DLinkedNode* node) {
        node->prev = head;
        node->next = head->next;
        head->next->prev = node;
        head->next = node;
    }
    void removeNode(DLinkedNode* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }
    void moveToHead(DLinkedNode* node) {
        removeNode(node);
        addToHead(node);
    }
    DLinkedNode* removeTail() {
        DLinkedNode* node = tail->prev;
        removeNode(node);
        return node;
    }
};

300. 最长递增子序列
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if(nums.size()==0) return 0;
        int n=nums.size();
        vector<int>dp(n,0);
        for(int i=0;i<n;i++){
            dp[i]=1;
            for(int j=0;j<i;j++){
                if(nums[i]>nums[j]){
                    dp[i]=max(dp[i],dp[j]+1);
                }
            }
        }
        return *max_element(dp.begin(),dp.end());
    }
};

142. 环形链表 II
给定一个链表，返回链表开始入环的第一个节点，如果链表无环，则返回null
为了表示给定链表的环，我们使用整数pos来表示链表尾连接到链表中的位置，如果pos是-1，则代表链表无环

思路：要返回环的入口节点，第一步首先找到环，第二部找环的第一个入口节点
1.使用快慢指针，快指针走两步，慢指针走一步，两个指针相遇的时候代表有环（使用一个bool变量来记录），若快指针走到链表尾尾空的位置，表示无环，返回null
2.找环的第一个节点，也使用双指针，定义一个指向头节点的指针，和slow指针同步走，两者相遇的节点就是环的入口节点
步骤2的解析：假设链表有a+b个节点，a是环前面的节点个数，b是环的节点个数，如果快慢指针走n圈相遇，fast=2slow，fast=slow+nb（双指针都走过a个节点，然后在环内同一个节点相遇，fast比slow多走环的整数倍)，则slow=nb。对于从头节点开始的，走过k+nb步就可以到环的入口节点，目前slow走了nb步，只要让其再走k步就到了入口节点，如何求k，那就再定义一个从头部开始的指针，和slow指针一起走，两指针相遇的节点就是我们要求的。
struct ListNode{
    int val;
    ListNode *next;
    ListNode(int _val):val(_val),next(nullptr){}
};
class Solution{
    ListNode *detectCycle(ListNode *head){
        if(head==nullptr||head->next==nullptr) return -1;
        ListNode*fast=head,*slow=head;
        bool haveCycle=false;
        //1.找环
        while(fast->next!=nullptr&&fast->next->next!=nullptr){
            fast=fast->next->next;
            slow=slow->next;
            if(fast==slow){
                haveCycle=true;
                break;
            }
        }
        //找环的起点
        if(haveCycle){
            ListNode* p=head;
            while(p!=slow){
                p=p->next;
                slow=slow->next;
            }
            return p;
        }else{
            return nullptr;
        }
    }
};

139. 单词拆分
给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
思路：使用动态规划，dp[i]表示前面0~i-1的字符串是否可以进行拆分，每次对i前面字符串进行枚举拆分点，j为拆分点，s1为0~j的字符串，s2为j~i-1的字符串，如果dp[j]为true，s2在词典中能够找到，那么dp[i]也为true，只用检查j~i-1之间是否为词典中的单词就行
动态转移方程：dp[i]=dp[j]&&check(s[j],s[i-1])
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordDict_set;
        vector<bool>dp(s.size()+1,false);
        for(auto word:wordDict){
            wordDict_set.insert(word);
        }
        dp[0]=true;
        for(int i=1;i<=s.size();i++){
            for(int j=0;j<i;j++){
                if(dp[j]&&(wordDict_set.find(s.substr(j,i-j))!=wordDict_set.end())){
                    dp[i]=true;
                    break;
                }
            }
        }
        return dp[s.size()];
    }
};

48. 旋转图像
给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。

思路：先将矩阵转置，然后再翻转就可以了
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n=matrix.size();
        for(int i=0;i<n;i++){
            for(int j=0;j<i;j++){
                swap(matrix[i][j],matrix[j][i]);
            }
        }
        for(int i=0;i<n;i++){
            for(int x=0,y=n-1;x<y;x++,y--){
                swap(matrix[i][x],matrix[i][y]);
            }
        }
    }
};

114. 二叉树展开为链表
给你二叉树的根结点 root ，请你将它展开为一个单链表：
    展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
    展开后的单链表应该与二叉树 先序遍历 顺序相同。

思路：前序遍历二叉树，将遍历的节点都放到一个数组中。然后使用双指针将数组中的元素接到root后面，注意将左孩子节点置为空
class Solution {
public:
    void flatten(TreeNode* root) {
        vector<TreeNode*>list;
        preOrder(root,list);
        TreeNode* cur,*pre;
        for(int i=1;i<list.size();i++){
            cur=list[i-1];
            pre=list[i];
            cur->left=NULL;
            cur->right=pre;
            cur=pre;

        }

    }
    void preOrder(TreeNode* root,vector<TreeNode*>& list){
        if(root==nullptr) return;
        list.push_back(root);
        preOrder(root->left,list);
        preOrder(root->right,list);
    }
};

62. 不同路径
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？

思路：动态规划 dp[i][j]=dp[i-1][j]+dp[i][j-1]
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>>res(m,vector<int>(n,0));
        for(int i=0;i<m;i++){
            res[i][0]=1;
        }
        for(int i=0;i<n;i++){
            res[0][i]=1;
        }
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                res[i][j]=res[i-1][j]+res[i][j-1];
            }
        }
        return res[m-1][n-1];
    }
};

42. 接雨水
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

思路1：动态规划，左右遍历两次，取每一个元素左右最大高度
class Solution {
public:
    int trap(vector<int>& height) {
        //动态规划
        if(height.size()==0) return 0;
        int n=height.size();
        //从左到右遍历，left_max存放包含位置i及其左边的元素中最大的数
        vector<int>left_max(n,0);
        left_max[0]=height[0];
        for(int i=1;i<n;i++){
            left_max[i]=max(left_max[i-1],height[i]);
        }
        //从右到左遍历，right_max存放位置i的右边元素中的最大元素
        vector<int>right_max(n,0);
        right_max[n-1]=height[n-1];
        for(int i=n-2;i>=0;i--){
            right_max[i]=max(right_max[i+1],height[i]);
        }
        int res=0;
        for(int i=0;i<n;i++){
            //取i左右最小的最大高度差
            res+=(min(left_max[i],right_max[i])-height[i]);
        }
        return res;
    }
};

思路2：双指针，只用遍历一次
用height[left]和height[right]更新left_max和right_max的值
height[left]<height[right]时，left_max<right_max，计算left处的接水量left_max-height[left]，left++
height[right]<=height[left]时，left_max>=right_max，计算right处的接水量right_max-height[right]，right++
//双指针遍历
        int res=0;
        int left_max=0,right_max=0;
        int left=0,right=n-1;
        while(left<right){
            left_max=max(left_max,height[left]);
            right_max=max(right_max,height[right]);
            if(height[left]<height[right]){
                res+=left_max-height[left];
                left++;
            }
            else{
                res+=right_max-height[right];
                right--;
            }
        }
        return res;

337. 打家劫舍 III
在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。
思路：题意其实就是求 在未同时选中父子节点的情况下树的最大权值和
动态规划：假设f(o)表示选择节点o的子树的最大权值和,g(o)表示不被选择的最大权值和
节点o被选中时，左右子节点不会被选中，f(o)=g(l)+g(r)
节点不被选择时，左右节点可能会被选中，也可能不被选中，那就选这两者的最大值
                                          g(o)=max{f(l)+g(l)}+max{f(r)+g(r)}
最后的结果取g(o)和f(o)的最大值
class Solution {
public:
    //f(o)表示选择节点o的子树的最大权值和,g(o)表示不被选择的最大权值和
    unordered_map<TreeNode*,int>f,g; //使用哈希表存储节点被选中、不被选中的子树的最大权值和
    //深度优先遍历二叉树，后序遍历
    void dfs(TreeNode* node){
        if(node==nullptr) return;
        dfs(node->left);
        dfs(node->right);
        f[node]=node->val+g[node->left]+g[node->right];
        g[node]=max(f[node->left],g[node->left])+max(f[node->right],g[node->right]);
    }
    int rob(TreeNode* root) {
        dfs(root);
        return max(f[root],g[root]);
    }
};

56. 合并区间
以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

思路：
1.将数组进行排序
2.遍历数组，使用t表示当前的区间的末尾，如果后面区间的起始值小于t，就将其合并进来，直到没有重合，然后将其存到结果数组res中，再更新i的值，继续遍历下一个区间
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        sort(intervals.begin(),intervals.end());
        vector<vector<int>>res;
        for(int i=0;i<intervals.size();){
            int t=intervals[i][1];   //t表示当前的区间末尾
            int j=i+1;
            while(j<intervals.size()&&intervals[j][0]<=t){
                t=max(t,intervals[j][1]);
                j++;
            }
            res.push_back({intervals[i][0],t});
            i=j;
        }
        return res;
    }
};

394. 字符串解码
给定一个经过编码的字符串，返回它解码后的字符串。
编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。

思路：使用2个辅助栈，一个数字栈用来存k值，一个存放字符串的栈，存放当前累加之后的字符串
           遍历字符串：1.字符为数字，计算当前num值；2.字符为'['，就将前边计算的num值压入数字栈，将cur压入字符串栈，同时将两者置0、清空，以便于后边的遍历计算；3.字符为字母，更新字符串cur；4.字符为']'，取出数字栈的栈顶元素，取出字符串栈的栈顶元素top()，将cur复制k次并加到top()中，再更新cur为当前栈顶
class Solution {
public:
    string decodeString(string s) {
        int n=s.size();
        stack<int>num_stack;
        stack<string>str_stack;
        string res="";
        string cur="";
        int num=0;
        for(int i=0;i<n;i++){
            if(s[i]>='0'&&s[i]<='9'){
                //如果当前字符为数字
                num=num*10+s[i]-'0';
            }
            else if(s[i]=='['){
                //遇到'['就将前边计算的整数压入数字栈，将前边的cur字符串压入字符栈，并置空后重新计算后边的
                num_stack.push(num);
                num=0;
                str_stack.push(cur);
                cur="";
            }
            else if(s[i]>='a'&&s[i]<='z'||s[i]>='A'&&s[i]<='Z'){
                //遇到字母,更新cur字符串
                cur+=s[i];
            }
            else if(s[i]=']'){
                //遇到']',取出数字栈栈顶元素k,将cur复制k次到字符栈栈顶中，再更新cur
                int tmp=num_stack.top();
                num_stack.pop();
                for(int j=0;j<tmp;j++){
                    str_stack.top()+=cur;
                }
                cur=str_stack.top();
                str_stack.pop();
            }
        }
        res=res+cur;
        return res;
    }
};

560. 和为K的子数组
给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。

思路：1.暴力法，sum[j,i]，对每一个元素，向前遍历穷举j
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int count = 0;
        for (int start = 0; start < nums.size(); ++start) {
            int sum = 0;
            for (int end = start; end >= 0; --end) {
                sum += nums[end];
                if (sum == k) {
                    count++;
                }
            }
        }
        return count;
    }
};

2.前缀和+哈希表：0到i的和为presum[i]，0到j的和为presum[j]，sum[j,i]==k可以转化为presum[i]-presum[j]==k，从而转化为presum[j]=presum[i]-k，那么和为k出现的次数就是presum[j]满足前面公式出现的次数。利用哈希表存储presum[j]出现的次数
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int,int> hash;
        hash[0]=1;
        int pre=0,res=0;
        for(int i=0;i<nums.size();i++){
            pre+=nums[i];
            if(hash[pre-k]) res+=hash[pre-k];
            hash[pre]++;
        }
        return res;
    }
};

647. 回文子串
给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。
具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串

思路：中心扩展法，穷举每一个元素，以其为中心的 可能向两边扩展，如果字符个数为奇数中心只有一个，如果是偶数那中心为两个
class Solution {
private:
    int res=0;
public:
    int countSubstrings(string s) {
        //中心向外扩展
        for(int i=0;i<s.size();i++){
            count(s,i,i);
            count(s,i,i+1);
        }
        return res;
    }
    void count(string s,int left,int right){
        while(left>=0&&right<s.size()&&s[left]==s[right]){
            res++;
            left--;
            right++;
        }
    }
};

33. 搜索旋转排序数组
给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。
思路：二分查找，首先要知道，旋转后的数组一定是一半有序，另一半可能有序可能无序。将数组二分后，如果nums[mid]<nums[right]，则右边有序，然后在两边分别找target在哪边，如果nums[mid]<nums[right]，则左边有序，再找target范围在哪边
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n=nums.size();
        if(n==0) return 0;
        int left=0,right=n-1;
        while(left<=right){
            int mid=(left+right)/2;
            if(nums[mid]==target) return mid;
            else if(nums[mid]<nums[right]){
                //右边是有序的，再判断target是在有序的一边还是在另外一边
                if(nums[mid]<target&&target<=nums[right]){
                    left=mid+1;
                }
                else{
                    right=mid-1;
                }
            }
            else{
                //左边是有序的
                if(nums[mid]>target&&target>=nums[left]){
                    right=mid-1;
                }
                else{
                    left=mid+1;
                }
            }
        }
        return -1;
    }
};

78. 子集
给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

思路：递归回溯。1.先画出递归树，确定回溯函数的参数，注意需要一个start变量标记当前的可选择列表的起始位置。2.确立结束条件（因为每条路径都要放入结果集中，所以超过数组大小后会自动结束）3.找选择列表（start-->nums.size()）4.判断是否需要剪枝（路径没有重复的就不用剪枝）5.做出选择，6.撤销选择，换下一条路径

class Solution {
private:
    vector<vector<int>>res;
public:
    void TraceBack(vector<int>& nums,vector<int> paths,int start){
        res.push_back(paths);
        //子集的选择列表，是上一条选择路径之后的数
        for(int i=start;i<nums.size();i++){
            paths.push_back(nums[i]);//做出选择
            TraceBack(nums,paths,i+1); //递归进入到下一层
            paths.pop_back();  //撤销选择
        }
    }
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<int>paths;
        TraceBack(nums,paths,0);
        return res;
    }
};

96. 不同的二叉搜索树
给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

思路：动态规划
dp[n]=dp[1]+dp[2]+....dp[n]
dp[i]=dp[j]*dp[i-j-1]
class Solution {
public:
    int numTrees(int n) {
        //if(n==0) return 1;
        vector<int>dp(n+1);
        dp[0]=1;
        dp[1]=1;
        for(int i=2;i<=n;i++){
            for(int j=1;j<=i;j++){
                dp[i]+=dp[j-1]*dp[i-j];
            }
        }
        return dp[n];
    }
};

309. 最佳买卖股票时机含冷冻期
给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​
设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

思路：动态规划.对当前位置i，有三种状态：
1.第i天不持有，且没卖出（因为之前没有股票）dp[i][0]，代表当前的股票最大收益
2.第i天持有，dp[i][1]，代表持有使当前的股票最大收益
3.第i天不持有，是因为当天卖出了，dp[i][2]，代表卖出后股票最大收益
对前面三种选择，有如下几种情况：
1.对dp[i][0]，选择后有两种情况，一是前一天不持股也没卖，二是前一天持股但卖了
2.对dp[i][1]，选择后也有两种情况，一是前一天持有的今天继承了，二是前一天没持股也没卖，今天买入的
3.对dp[i][2]，只有一种情况，前一天持有，今天卖
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n=prices.size();
        if(n<=1) return 0;
        vector<vector<int>>dp(n,vector<int>(3,0));
        dp[0][0]=0;//不持股，没卖出
        dp[0][1]=-prices[0];//持股，当天买入的
        dp[0][2]=0; //不持股，当天卖了的
        for(int i=1;i<n;i++){
            dp[i][0]=max(dp[i-1][0],dp[i-1][2]);//两种情况：前一天不持股也没卖；或者前一天持股但卖掉了
            dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i]);//持股，两种情况：前一天持有的股票今天继承的；前一天不持股也没卖出，今天买入的
            dp[i][2]=dp[i-1][1]+prices[i];//不持股，今天卖,只有一种情况就是前边持有
        }
        return max(dp[n-1][0],dp[n-1][2]);
    }
};

338. 比特位计数
给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

思路：遍历每一个数，对每一个计算二进制位个数
class Solution {
public:
    int countOne(int x){
        int count=0;
        while(x>0){
            count++;
            x=x&(x-1);
        }
        return count;
    }
    vector<int> countBits(int num) {
        vector<int>res(num+1);
        for(int i=0;i<=num;i++){
            res[i]=countOne(i);
        }
        return res;
    }
};

11. 盛最多水的容器
        给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。


class Solution {
public:
    int maxArea(vector<int>& height) {
        //双指针,容水量为左右指针中最小的值×距离，每次向前移动较小的指针，因为距离变短了，如果移动较大的那个，最大值可能会变小，移动较小的，容量可能还会增大
        int ll=0,rr=height.size()-1;
        int res=0;
        int tmp=0;
        while(ll<rr){
            tmp=min(height[ll],height[rr])*(rr-ll);
            res=max(res,tmp);
            if(height[ll]<height[rr]){
                ++ll;
            }
            else{
                --rr;
            }
        }
        return res;
    }
};

22. 括号生成

数字 n 代表生成括号的对数，请你设计一个函数，输出用于能够生成所有可能的并且 有效的 括号组合。
class Solution {
public:
    //回溯
    void func(vector<string>& res,string str,int l,int r,int n){
        if(l>n||r>n||r>l) return;
        if(l==n&&r==n){
            res.push_back(str);
            return;
        }
        func(res,str+'(',l+1,r,n);
        func(res,str+')',l,r+1,n);
        return;
    }
    vector<string> generateParenthesis(int n) {
        vector<string>res;
        func(res,"",0,0,n);
        return res;
    }
};

23. 合并K个升序链表
给你一个链表数组，每个链表都已经按升序排列。
请你将所有链表合并到一个升序链表中，返回合并后的链表。
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1,ListNode* l2){
        ListNode* res=new ListNode(0);
        ListNode* p=res;
        if(l1==nullptr) return l2;
        if(l2==nullptr) return l1;
        while(l1!=nullptr&&l2!=nullptr){
            if(l1->val<l2->val){
                p->next=l1;
                l1=l1->next;
            }
            else{
                p->next=l2;
                l2=l2->next;
            }
            p=p->next;
        }
        if(l1){
            p->next=l1;
        }
        if(l2){
            p->next=l2;
        }
        return res->next;
    }
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if(lists.size()==0) return nullptr;
        if(lists.size()==1) return lists[0];
        if(lists.size()==2) return mergeTwoLists(lists[0],lists[1]);
        vector<ListNode*> subList1,subList2;
        int mid=lists.size()/2;
        //拆分成两个链表
        for(int i=0;i<mid;i++){
            subList1.push_back(lists[i]);
        }
        for(int i=mid;i<lists.size();i++){
            subList2.push_back(lists[i]);
        }
        ListNode *l1=mergeKLists(subList1);
        ListNode *l2=mergeKLists(subList2);
        return mergeTwoLists(l1,l2);
    }
};

46. 全排列
给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。


class Solution {
public:
    void dfs(vector<vector<int>>&res,vector<int> path,int start,int k){
        if(start==k){
            res.push_back(path);
            return;
        }
        for(int i=start;i<k;i++){
            //动态维护路径数组
            swap(path[i],path[start]);
            //继续递归填下一个数
            dfs(res,path,start+1,k);
            //撤销操作
            swap(path[i],path[start]);
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>>res;
        dfs(res,nums,0,nums.size());
        return res;
    }
};

39. 组合总和
给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的数字可以无限制重复被选取。

思路：回溯。终止条件：start走到数组末尾return，或者target==0时。每次选择元素的时候，有两种选择，①选择当前元素，target变为target-candidates[start]，②跳过当前元素，将start往前进一个即可。
class Solution {
public:
    void dfs(vector<int>& candidates,vector<vector<int>> &res,vector<int> &cur,int start,int target){
        if(start==candidates.size()) return;
        if(target==0){
            res.push_back(cur);
            return;
        }
        //跳过当前的元素
        dfs(candidates,res,cur,start+1,target);
        //选择当前的元素
        if(target-candidates[start]>=0){
            cur.push_back(candidates[start]);
            dfs(candidates,res,cur,start,target-candidates[start]);
            cur.pop_back();
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>>res;
        vector<int>cur_array;
        dfs(candidates,res,cur_array,0,target);
        return res;
    }
};

64. 最小路径和
给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

思路：动态规划
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int rows=grid.size(),cols=grid[0].size();
        if(rows==0||cols==0) return 0;
        vector<vector<int>>dp(rows,vector<int>(cols,0));
        dp[0][0]=grid[0][0];
        for(int i=1;i<rows;i++){
            dp[i][0]=dp[i-1][0]+grid[i][0];
        }
        for(int i=1;i<cols;i++){
            dp[0][i]=dp[0][i-1]+grid[0][i];
        }
        for(int i=1;i<rows;i++){
            for(int j=1;j<cols;j++){
                dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j];
            }
        }
        return dp[rows-1][cols-1];
    }
};

406. 根据身高重建队列
假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。
请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

思路：身高从大到小排列，身高相同的话让k小的排在前面。（按照身高排序之后，优先按身高高的人的k来插入，后续插入的节点也不会影响前面已插入的节点）
class Solution {
public:
    static bool cmp(const vector<int> a,const vector<int> b){
        if(a[0]==b[0]) return a[1]<b[1];//身高相等的情况下，k小的放前边
        return a[0]>b[0];   //身高不同的情况下，由高到低排列
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(),people.end(),cmp);
        vector<vector<int>>res;
        for(int i=0;i<people.size();i++){
            int position=people[i][1]; //每个人前边的高的人数，就是position插入的的位置
            res.insert(res.begin()+position,people[i]);
        }
        return res;
    }
};

739. 每日温度
请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。
例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        vector<int>res(temperatures.size(),0);
        stack<int> stack;
        stack.push(0);
        for(int i=1;i<temperatures.size();i++){
            if(temperatures[i]<temperatures[stack.top()]){
                //当前元素小于栈顶元素
                stack.push(i);
            }
            else if(temperatures[i]==temperatures[stack.top()]){
                //当前元素等于栈顶元素
                stack.push(i);
            }
            else{
                while(!stack.empty()&&temperatures[i]>temperatures[stack.top()]){
                    res[stack.top()]=i-stack.top();
                    stack.pop();
                }
                stack.push(i);
            }
        }
        return res;
    }
};


49. 字母异位词分组
给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串.

思路：哈希表，遍历字符数组，将字符排序之后的作为键值，每一个字符串放入相应键值的value里，然后遍历哈希表将每一个放入结果数组中

c
