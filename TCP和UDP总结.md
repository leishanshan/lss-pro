TCP和UDP总结
https://blog.csdn.net/hansionz/article/details/86435127
传输层：TCP/IP协议模型的第第四层，提供应用层之间的通信，负责数据从发送端传输到接收端
端口号：表示主机上进行通信的不同应用程序。TCP/IP协议里面用（源IP，源端口号，目的IP，目的端口号，协议号）五元组来标识一个通信，一个进程可以绑定多个端口号
端口号范围：0-1023是知名端口号，HTTP,FTP,等这些端口号都是固定的；1024-65535是操作系统动态分配的端口号，客户端程序的端口号由这个范围分配
UDP协议
##UDP报文组成：源端口，目的端口，数据包长度，校验值，数据
##特点：
1.无连接，只知道对方的ip和端口号就可以发送数据，不需要建立连接
2.不可靠：没有确认机制和重传机制，如果出现网络故障无法发送给对方，UDP协议层也不会给应用层返回任何错误信息
3.面向数据报：应用层交给UDP多长的报文，UDP原样发送不会拆分也不会合并，如果发送端调用一次sendto，发送100个字节，那接收端也必须调用对应的一次recvfrom，接收100个字节，而不能循环调用10次recvfrom，每次接收10个字节，所以udp不能灵活的控制读写数据的次数和数量。
##UDP缓冲区：UDP存在接收缓冲区，但没有发送缓冲区。
UDP没有发送缓冲区，在调用sendto时会直接将数据交给内核，由内核将数据交给网络层协议进行后续的传输工作，为什么不需要发送缓冲区？因为UDP不保证可靠性，没有重传和确认机制，出现丢包时不需要重新传送，缓冲区没有必要。但是TCP不同，因为报文丢失的时候TCP必须保证重新发送，用户不用管，但是必须要有发送缓冲区
UDP有接收缓冲区，但是接收缓冲区不能保证报文收到的顺序和发送的顺序是否一致，缓冲区满了之后再到达的报文会被丢弃（TCP接收缓冲区不会溢出因为TCP有流量控制，UDP是没有流量控制的，较快的发送端发送的数据可以很容易的淹没较慢的接收端，导致接收端的UDP丢弃数据报）
##常见基于UDP的应用层协议：DHCP动态主机配置协议，DNS域名解析协议，TFTP简单文件传输协议

TCP协议
##TCP报文组成：源端口，目的端口，序号，确认号，数据偏移，校验和，标志位等等
32位序号:序号是传送数据很重要的因素，TCP将要传输的每个字节都进行了编号，序号是本报文段发送的数据组的第一个字节的编号，序号可以保证传输信息的有效性（比如一个报文段的序号为300，此报文段数据部分有100字节，下一个报文段的序号就是401）
32位确认号：每一个ACK对应这一个确定号，指明了下一个期待收到的字节序号，表明在该确认号之前的数据都已经正确无误的收到，确认号只有在ACK标志位为1时才有效。比如建立连接的时候ACK标志位为0

确认应答机制（右图1）
接收端接收到一条报文之后，向发送端发送一条确认ACK，这条确认信息的目的就是告诉发送端已经成功收到了消息，并且希望收到的下一个序号是什么

##超时重传（右图2）
TCP在传输过程中加入超时重传机制。假设A给B发送数据包，主机B没有收到，于是没有应答，或者ACK丢失了，如果主机A在一定时间间隔内没有收到B的确认应答，就会进行重发。主机B会收到很多重复数据，TCP就需要识别出哪些是重复的包，并把重复的包丢掉，这时候就可以利用序列号实现。


##连接管理机制
1.三次握手

①第一次握手：建立连接，客户端发送SYN包（syn=j）到服务器，进入SYN_SENT状态，等待服务器确认
②第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送以后个SYN包（syn=k），此时服务器进入到SYN_RECV状态
③第三次握手：客户端收到服务端的ACK+SYN包，向服务器发送确认包ACK(ack=k+1)此包发送完毕，客户端和服务端TCP连接成功，完成三次握手
2.四次挥手

①客户端发送连接释放报文，FIN=1，序列号seq=u，此时客户端进入FIN-WAIT-1状态
②服务端收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并发出序列号seq=v，服务端进入CLOSE-WAIT状态。客户端向服务端的方向就释放了，这时候是半关闭的状态，客户端已经没有数据发送了（在这之前还需要接收服务器发送的数据）
③客户端收到服务端的确认请求后，进入FIN-WAIT-2状态，等待服务端发送连接释放报文
④服务端最后的数据传输完毕，就向客户端发送连接释放报文，FIN=1,ack=u+1，序列号为seq=w，服务器就进入LAST-WAIT状态，等待客户端的确认
⑤客户端收到服务端的连接释放报文后，必须发送确认，ACK=1,seq=u+1，此时客户端进入TIME-WAIT阶段，此时TCP还没有释放，必须经过2*MSL的时间后，才进入CLOSED状态
⑥服务端只要收到了客户端的确认，立即进入CLOSED状态，撤销TCB之后就结束TCP连接

###问1：为什么连接的时候是三次握手，关闭的时候是四次挥手？
连接的时候，服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文，ACK用来应答，SYN用来同步，这俩可以放在一起发送。但是关闭连接的时候，服务端收到FIN报文时，可能还有数据发送不会关闭SOCKET，所以只能先回复一个ACK报文告诉客户端，你发送的FIN报文我收到了，只有等服务端的所有报文发送完了，才能发送FIN报文，因此不能一起发送，就必须是四次挥手
###问2：为什么不能用两次握手进行连接？
三次握手需要双方都做好发送数据的准备工作，同时也要允许双方就初始序列号进行协商，这个协商的序列号在握手过程中被发送和确认
如果把三次握手改成两次握手，可能发生死锁。假如客户端c和服务端s通信，客户端给服务端发送了一个连接请求分组，服务端收到请求后发送了确认应答分组，但是这个应答分组丢失了，客户端收不到，就认为服务端没准备好，不知道建立什么样的序列号，这种时候服务端给客户端发送的任何数据分组都会被客户端忽视，而客户端只会等待连接确认应答分组。对服务端来说发出的分组超时之后，就会重发同样的分组，这样就形成了死锁。‘
###问3：为什么TIME_WAIT阶段要经过2MSL才进入CLOSED状态？
假设网络是不可靠的，有可能最后一个客户端发出的ACK丢失，未收到ACK的服务端就会重复发送FIN报文，这个重复发送的时间就是两倍的MSL。客户端不能立即关闭，如果在该时间再次收到FIN，就会重发ACK并再次等待2MSL，如果客户端在2MSL之后都没有再收到FIN，说明服务端成功接收了ACK，那就可以结束TCP了。
###客户端出现故障怎么搞？
TCP有一个保活计时器，客户端如果出现故障，服务端不能白等下去，所以服务器每收到一次客户端的请求都会重新复位这个计时器。加入设置时间2小时，超过这个时间还没有收到客户端的数据，服务器就会发送一个探测报文段，之后每隔75秒发送一次，若连续10个探测报文仍然没反应，服务器就认为客户端出现故障，接着关闭连接。
