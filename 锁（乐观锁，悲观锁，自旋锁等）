在多线程编程里面，为了保证数据的一致性引入锁机制，用于保证临界区代码的安全。通过锁机制，保证在多核多线程环境中，在某一个时间点上，只能有一个线程进入临界区代码，从而保证临界区中操作数据的一致性。
所谓锁，就是内存中的一个整型数，拥有两种状态：空闲状态和上锁状态。加锁时，判断锁是否空闲，如果空闲，修改为上锁状态，返回成功；如果已经上锁，则返回失败。解锁时，把锁状态修改为空闲状态。
1.悲观锁：
总是假设最坏的情况，每次去拿数据的时候都认为别人会修改（认为总会发生数据冲突），所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库就用到了这种锁机制，比如行锁、表锁等，读锁、写锁等，都是在操作之前先上锁。
1.1重量级锁
当进入一个同步、线程安全的方法时，需要先获得该方法的锁，退出这个方法时需要释放锁。如果线程A获取不到锁，则以为着该方法有别的线程在执行，这是线程A会马上进入一个阻塞的状态，直到锁被先前持有的线程释放，才会从阻塞状态被唤醒，再尝试去获取该方法的锁。
重量级锁特点：获取不到锁，马上进入阻塞状态。效率有时候会很慢。当A发现锁被占用，立即进入阻塞状态，之后的0.00001s，这个锁被释放了，它又从阻塞进入运行状态，线程从运行状态进入阻塞状态需要保存线程的执行状态、上下文等数据，以及涉及到用户态到内核态的转换，非常耗时，阻塞状态转到运行状态同理。总的来说就是重量级锁这个马上进入阻塞状态的特点往往会耗费很多的时间在状态转换中。
1.2自旋锁
自旋锁在重量级锁的基础上做了一些改进，它在线程A判断方法有别的线程执行之后，不会立马进入阻塞状态，而是等待一段时间，也就是在一段固定的循环时间内，看看这个锁有没有释放，如果一直没有释放才会进入阻塞状态。自旋锁特点就是：获取不到锁，等一段固定时间，再进入阻塞状态。
1.3自适应自旋锁
在自旋锁的基础上，对一段固定时间做了调整：不需要认为指定这一段固定时间是多久，是根据线程最近获得锁的状态来调整循环次数，尽量减少等待时间。
2.乐观锁
乐观锁总是假设最好得情况，每次去拿数据的时候都认为不会被别人修改（不会发生数据冲突），所以不会上锁，出现了冲突再想办法解决，在更新的时候会判断一下在此期间有没有别人去更新这个数据，这个通过版本号和CAS算法实现。乐观锁多用于多读的应用类型，这样可以提高吞吐量
2.1CAS机制（compare and swap比较并替换）
CAS机制采用3个基本操作数，分别是内存地址V、旧预期值A、新值B。当线程在更新一个变量的时候，只有当变量的旧预期值A和内存地址V当中的实际值相同的时候，才会将内存地址V对应的值修改为B
举例子：有两个线程A、B，都想要将内存地址V中的值加1，内存地址V当中的初始值为10
①对线程A来说旧预期值为10，新值B为11；
②当线程A提交更新前，线程B抢先一步将内存地址当中的值加1变成了11
③此时A开始提交更新，将旧预期值A与内存地址V中的值进行比较，发现不等，提交失败；
④线程A重新尝试获取旧预期值A=11，新值B=12，该重新尝试的过程称为自旋；
⑤线程A提交更新，旧预期值A与内存地址V的值相同，提交更新，此时内存地址V中的值更新为B，也就是12
CAS缺点：（1）CPU开销过大：在并发量比较高的情况下如果许多线程反复尝试更新某一变量，却又一直更新不成功，循环往复会给CPU带来很多压力；（2）不能保证代码块的原子性：CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码的原子性。（3）ABA问题：这是CAS机制最大的问题所在，通常会加入版本号，每次变量更新的时候变量的版本号都+1，即A->B->A变成1A->2B->3A，从而有效的解决ABA问题
补充ABA问题：小明在提款机提取了50元，因为提款机问题有两个线程同时把余额100变成50
线程1(提款机)：获取当前值100，期望更新值为50
线程2(提款机)：获取当前值100，期望更新值为50
线程1成功执行，线程2因为某种原因阻塞了，这时候有人给小明汇款50
线程3：获取当前值50，期望更新值为100
这时候线程3成功执行，余额变为100
线程2恢复，获取到的值为100，compare之后继续更新余额为50！！！
此时可以看到余额本来应为100（100-50+50），但实际上变为了50（100-50+50-50），这就是ABA带来的问题！！！
2.2轻量级锁
轻量级锁会认为很少有线程刚好也来执行相同的方法，所以进入一个方法的时候根本不用加锁，只需要做一个标记，也就是一个变量，来记录此时该方法是否有人在执行，当该方法没有在执行的时候采用CAS机制，将方法的状态标记为正在执行，当退出方法的时候，再将状态标记为没有执行，使用CAS机制改变状态，是因为对状态的改变并不是原子操作，所以会使用CAS机制来保证操作的原子性。
2.3偏向锁
如果是线程首次执行该方法，便采用CAS机制将其标记为有人在执行，同时会将线程ID记录进去，以标记是哪个线程正在执行。而当线程退出该方法时，不会改变其状态，而是直接退出，因为其默认除了本线程，其他线程不会执行该方法，当这个线程想要再次执行该方法的时候，会判断其状态，如果已经被标记为有人在执行并且线程的ID是自己，那么就直接执行方法。

