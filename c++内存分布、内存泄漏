内存分布
程序运行时操作系统给每个进程分配一个4G的地址空间，当然，都是虚拟地址空间，分布如下：

1.进程地址空间中的内核空间1G：是给操作系统使用的，用户没有操作权限
2.栈区（向下增长）：存放函数的局部变量，函数函数返回值，函数调用期间所有参数压栈，这一段内存由操作系统自己维护，函数结束之后栈的空间由操作系统自己回收
3.内存映射段：存放动态库/静态库，以及文件映射
4.堆区（向上增长）：用户所操作的空间就是堆上空间，使用malloc/new等申请，free/delete释放，用户堆上申请的空间必须自己释放，否则会内存泄露
5.数据段：数据段存放全局变量、静态类型的变量，这些数据在程序运行之前就已经加载到内存中了，即main函数之前这些数据就已经划分好空间了
6.代码段：可执行代码
堆和栈的区别分析
1.申请和回收空间的方式不同
栈：系统自动分配，自动回收
堆：手动分配，手动释放，容易内存泄漏
2.申请之后系统的响应不同
栈：只要剩余空间大于申请的，就分配，否则就提示栈溢出
堆：操作系统有一个空闲内存的链表，申请的时候，寻找第一个符合条件的堆节点，从链表中删除后分配给程序，如果有多余的空间，就将多余的放入空闲链表中
3.由前边的响应方式不同，导致了两者的申请效率不同
栈：系统分配的，操作系统在底层对栈会提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以效率很高
堆：堆的操作是c++函数库提供的，在分配内存的时候需要一定的算法去寻找合适大小的内存，并且堆要访问两次，一次是访问指针，第二次根据前边的指针保存的地址访问内存。而且堆的分配会产生内部碎片，就有一些碎片的工作需要处理
4.存储的数据不同
栈：函数的参数，局部变量，函数返回值等。函数调用时，主函数中函数调用后的下一条指令地址第一个进栈，再是参数，然后是局部变量，调用结束后局部变量先出栈，然后参数出栈，最后是栈顶指针指向最开始的地址，程序由此运行。
堆：由程序员来决定存放什么
5.申请的大小两者有区别
栈：栈是向下增长，而且是连续的区域，所以栈顶地址和容量是系统规定好的，一般是2M
堆：向高地址扩展，不连续（因为是链表存储空闲地址），堆申请的大小受计算机虚拟内存大小的限制
内存泄漏
1.内存泄漏的原因和后果
内存泄漏是由于疏忽或错误造成程序未能释放已经不再使用的内存的情况，比如new出来的内存没有通过delete合理的释放掉。内存泄漏并不是指内存在物理上消失，而是应用程序分配了某段内存后，由于程序设计错误，导致在释放改内存之前就失去了对该段内存的控制，从而造成内存的浪费。内存泄漏的程序可能会用掉太多内存，导致另一个程序失败。后果是导致性能不良，内存会耗尽。
在类的构造函数和析构函数中没有匹配的调用new和delete函数，一是在堆里创建对象占用了资源，但没有显示的释放内存，二是在类的构造函数中动态的分配了内存，但是在析构函数中没有释放内存。
缺少拷贝构造函数和缺少重载赋值运算符。这种情况在类中涉及到资源的管理，类中默认的拷贝构造和赋值运算符重载都是浅拷贝的方式，一旦释放内存，就会导致一块内存被释放多次，产生内存泄漏，所以必须显式的给出深拷贝方式的拷贝构造和赋值运算符重载
2.内存泄漏的检测和查看
